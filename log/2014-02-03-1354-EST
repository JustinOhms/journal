Mon Feb  3 13:54:41 EST 2014

#~ Making Progress
I think I've identified the path forward now.
I'm going to implement the `fix` command.
By doing this first I'll be using my new packages and paving the way to re-implement the `new` command.
It also doesn't make much sense to implement the `new` command without a journal to use it on.
Opening a new Idea for the `fix` command.

## [active] git interfaces

- [ ] a CommitableChange can be Add(c CommitableChange)'ed to the index
    - should have a filepath for executing `git add {filepath}`
- [ ] a Commitable can be Commit(c Commitable)'ed to the repository
    - should have a list of CommitableChanges
    - should have a commit message

- [ ] A function to commit an empty commit with a message

## [active] `fix` command

- [ ] Mark upgrade beginning with an empty git commit
    - message "FIX - Begin - Upgrade JournalVersion_1_2"

- [ ] Identify Entry version
    - [ ] EntryVersion_1 has no ClosedAt timestamp.
    - [ ] EntryVersion_2 has ClosedAt timestamp and may have ideas.
    - [ ] EntryVersion_3 has ClosedAt timestamp and doesn't have any ideas.

- [ ] Identify Journal version
    - [ ] JournalVersion_1 does not have an `entry/` or `idea/` directory
        - [ ] JournalVersion_1 can ONLY contain EntryVersion_1 or EntryVersion_2
    - [ ] JournalVersion_2 uses `entry/` and `idea/` to store entries and ideas
        - [ ] JournalVersion_2 can ONLY contain EntryVersion_3

- [ ] Upgrade JournalVersion_1_2
    - [ ] Upgrade all EntryVersion_1's to EntryVersion_2's
    - [ ] Create `entry/` and `idea/`
    - [ ] Upgrade all EntryVersion_2's to EntryVersion_3's
        - [ ] Remove any ideas from the entry and store them in `idea/`
            - [ ] If and idea in `idea/` has the same name assume the idea's are the same and perform an Update instead of a Create
        - [ ] Store EntryVersion_3 in `entry/`
    - [ ] Mark upgrade complete with an empty git commit
        - message "FIX - Completed - Upgrade JournalVersion_1_2"

## [active] `idea/` directory

- [ ] `idea/nextid` will store the next available id
- [ ] `idea/active` will index which ideas are active
    - [ ] 1 id per line

- [ ] Create a new idea
    - [ ] Retrieve nextid and increment
        - [ ] Returns a CommitableChange
    - [ ] Write idea to `idea/{id}`
        - [ ] Returns a CommitableChange
    - [ ] If it is active, append id to `idea/active` index
        - [ ] Returns a CommitableChange

    - [ ] Create a Commitable with all 3 changes and a msg
        - [ ] commit message format "IDEA - {id} - Created"

- [ ] Update an existing idea
    - [ ] Write idea to `idea/{id}`
        - [ ] Returns a CommitableChange
    - [ ] If it is active, make sure it exists in `idea/active` index
        - [ ] If modified return a CommitableChange
    - [ ] If it is inactive, make sure it doesn't exist in `idea/active` index
        - [ ] If modified return a CommitableChange

    - [ ] Create a Commitable with all 3 changes and a msg 
        - [ ] msg format "IDEA - {id} - Updated"

## [inactive] Idea Storage
Right now each Idea is getting repeated with each entry.
In the short run this is fine and will work for the immediate future.
But in the long run I don't like it at all.

If we splice the Ideas out of the entry and store them by themselves we get the following for free.

- Modification tracking through git, don't have to make it ourselves
- Idea indexing by ID
- Can change the name of an Idea
- No stress to keep the Idea short
- Idea browsing without having to parse through all the previous journal entries

It's a persistent document, It should be treated as such.

So heres the plan.
Editing and saving Ideas will function the same.
They will be appended to the entry when it is made and you can edit them the same way.
When the entry is saved and the editor is closed we parse out the Ideas and removed them from the entry.
If an Idea is missing an Id, that means it's new and hasn't been seen before, so we give it one.

The Id is used as the filename for the Idea in the `$journal/idea/` directory.
Active Idea's can be indexed in the `$journal/idea/active` file, each line with an Id.
We store the next available Id in the `$journal/idea/next` file.

I should also go back and remove all the ideas from journal entries and bring them into the new system.
Should do this manually I think since I can track the renames and more major edits.
I could play around with automating this though, but I don't think it's worth the time right now.


Mon Feb  3 15:03:49 EST 2014
