Tue Feb  4 15:19:05 EST 2014

#~ Updated the git.Commitable interface
The user shouldn't be adding changes to the index in a non atomic way.
Using the git.Commit() function is atomic.
All the changes from the Commitable are added and committed.

Room for optimization by combining all `git add` call's into 1.

Of note, the git.Commit() function doesn't care if the index is already dirty.

## [active] git interfaces
- [X] a CommitableChange can be `git add`'ed to the index
    - will have a filepath for executing `git add {filepath}`
- [X] a Commitable can be Commit(c Commitable)'ed to the repository
    - will have a working directory
    - will have a list of changes
    - will have a commit message

- [ ] A function to commit an empty commit with a message

## [active] `fix` command
- [ ] Mark upgrade beginning with an empty git commit
    - message "FIX - Begin - Upgrade JournalVersion_1_2"

- [ ] Identify Entry version
    - [ ] EntryVersion_1 has no ClosedAt timestamp.
    - [ ] EntryVersion_2 has ClosedAt timestamp and may have ideas.
    - [ ] EntryVersion_3 has ClosedAt timestamp and doesn't have any ideas.

- [ ] Identify Journal version
    - [ ] JournalVersion_1 does not have an `entry/` or `idea/` directory
        - [ ] JournalVersion_1 can ONLY contain EntryVersion_1 or EntryVersion_2
    - [ ] JournalVersion_2 uses `entry/` and `idea/` to store entries and ideas
        - [ ] JournalVersion_2 can ONLY contain EntryVersion_3

- [ ] Upgrade JournalVersion_1_2
    - [ ] Upgrade all EntryVersion_1's to EntryVersion_2's
    - [ ] Create `entry/` and `idea/`
    - [ ] Upgrade all EntryVersion_2's to EntryVersion_3's
        - [ ] Remove any ideas from the entry and store them in `idea/`
            - [ ] If and idea in `idea/` has the same name assume the idea's are the same and perform an Update instead of a Create
        - [ ] Store EntryVersion_3 in `entry/`
    - [ ] Mark upgrade complete with an empty git commit
        - message "FIX - Completed - Upgrade JournalVersion_1_2"


## [active] `idea/` directory
- [ ] `idea/nextid` will store the next available id
- [ ] `idea/active` will index which ideas are active
    - [ ] 1 id per line

- [ ] Create a new idea
    - [ ] Retrieve nextid and increment
        - [ ] Returns a CommitableChange
    - [ ] Write idea to `idea/{id}`
        - [ ] Returns a CommitableChange
    - [ ] If it is active, append id to `idea/active` index
        - [ ] Returns a CommitableChange

    - [ ] Create a Commitable with all 3 changes and a msg
        - [ ] commit message format "IDEA - {id} - Created"

- [ ] Update an existing idea
    - [ ] Write idea to `idea/{id}`
        - [ ] Returns a CommitableChange
    - [ ] If it is active, make sure it exists in `idea/active` index
        - [ ] If modified return a CommitableChange
    - [ ] If it is inactive, make sure it doesn't exist in `idea/active` index
        - [ ] If modified return a CommitableChange

    - [ ] Create a Commitable with all 3 changes and a msg 
        - [ ] msg format "IDEA - {id} - Updated"


Tue Feb  4 15:28:39 EST 2014
