Thu Jan 30 13:58:27 EST 2014

#~ Completed Non-Error Specification of the entry package
Completed all the non error specifications for the entry package.
The one error case I really care about is if an Entry is missing a Commit message.
I think this error case can be handled by the package user to reopen the editor.
It needs to be checked during Close() and the file shouldn't be modified.

## [active] Impose Entry workflow that should prevent data loss
I'm also sort of worried about Ideas getting lost between Close() and when they've been written to files.
So I'm thinking maybe the package user calls OpenEntry.Ideas() before Close() and saves the Ideas then.
If that's successful, then Close() is called.
To impose this path on the user, the []idea.Idea return val from Close() will be removed.
This would force a call to Ideas() before Close() if the user wants a list of Ideas.
Then if there was an error while saving that list there still exist in the un-truncated entry file.

- [ ] Scan entry for Idea's in OpenEntry.Ideas() method
- [ ] Remove []idea.Idea rval from OpenEntry.Close()

## [completed] package entry
An entry is a simple state machine where each type is a state that has methods on it to transform it.
An entry has 3 states.

new -> open -> closed

A type NewEntry can be Open()'ed  which creates the file in the filesystem and returns an type OpenEntry.
An type OpenEntry can be Edit()'ed and Close()'d  which returns a type ClosedEntry.
A type ClosedEntry committable to git.

Note: The state when an entry is being edited currently isn't a type, but it may become one in the future.

I'm really happy with this design thus far.
Especially happy with the git.Commitable interface that will be implemented by ClosedEntry.
This is the type of decoupling that I was looking for during this redesign and I think I've found it.

- [X] OpenEntry Specification & Implementation
- [X] ClosedEntry Specification & Implementation

Before I can use the entry package in `newEntry()` I'll have to specify the git committable nature of the type idea.Idea.
This is because the only behavior of the entry package will be to remove the ideas from the entry file as it is being closed.
The process of saving Idea's as files will fall to the idea package.


## [active] Idea Storage
Right now each Idea is getting repeated with each entry.
In the short run this is fine and will work for the immediate future.
But in the long run I don't like it at all.

If we splice the Ideas out of the entry and store them by themselves we get the following for free.

- Modification tracking through git, don't have to make it ourselves
- Idea indexing by ID
- Can change the name of an Idea
- No stress to keep the Idea short
- Idea browsing without having to parse through all the previous journal entries

It's a persistent document, It should be treated as such.

So heres the plan.
Editing and saving Ideas will function the same.
They will be appended to the entry when it is made and you can edit them the same way.
When the entry is saved and the editor is closed we parse out the Ideas and removed them from the entry.
If an Idea is missing an Id, that means it's new and hasn't been seen before, so we give it one.

The Id is used as the filename for the Idea in the `$journal/idea/` directory.
Active Idea's can be indexed in the `$journal/idea/active` file, each line with an Id.
We store the next available Id in the `$journal/idea/next` file.

I should also go back and remove all the ideas from journal entries and bring them into the new system.
Should do this manually I think since I can track the renames and more major edits.
I could play around with automating this though, but I don't think it's worth the time right now.


Thu Jan 30 14:13:06 EST 2014
